---
title: "Data transformation"
subtitle: "<br><br> Environmental Data Analysis and Visualization"
author: "[https://mrne222-sp26.github.io/website/](https://mrne222-sp26.github.io/website/)"
format: 
  revealjs:
    theme: simple
    width: 1500
    margin: 0.05
slide-number: c/t
from: markdown+emoji
editor: 
  markdown: 
    wrap: 72
execute:
  echo: true
---

## We ate the cake (data viz first) {.center-h2}
<br>
```{css echo=FALSE}
.center-h2 h2 {
  text-align: center;
}
```

![](img/eat-cake-meme.jpg){fig-align="center" fig-alt="Drawing of a meme of marie antoinette saying let them eat cake"}


## Now we dive into everything you need to know get this result *on your own* with *any dataset*

<br>

![](img/draw-the-owl.jpg){fig-align="center" fig-alt="Drawing of an owl joke cartoon"}



## You are already asking the right questions

- How can I change the values of a categorical variable if they are not informative (e.g., change "OG" to "old growth")
- How can I calculate summary statistics (e.g., mean, max, min, etc.)
- What if I only want to analyze a subset of the columns or rows?
- How can I remove missing values (NAs)?


## First, we almost always need to transform our data

![](img/dplyr-horst.png){fig-align="center" fig-alt="cartoon of dplyr R package"}

## `dplyr` functions for data transformation

::: {.columns}
::: {.column width = "30%"}

![](img/dplyr-part-of-tidyverse.png){fig-alt="dplyr package hex logo"}

:::

::: {.column width = "70%"}
::: {style="font-size: 90%;"}
- `select`: pick columns by name
- `arrange`: reorder rows
- `slice`: pick rows using index(es)
- `filter`: pick rows matching criteria
- `distinct`: filter for unique rows
- `mutate`: add new variables
- `summarise`: reduce variables to values
- `group_by`: for grouped operations
- ... (many more)
:::

:::
:::

## Rules of `dplyr` functions

How functions work in R: `function_name(arguments...)` = output...

- With `dplyr` functions, the first argument is *always* a data frame

- Subsequent arguments say what to do with that data frame

- A data frame is always returned as the output


## Example data: Himalayn mountaineering expeditions

- Data[^1] from an archive documenting mountaineering expeditions in the Nepal Himalaya
- Observations: Each row represents a climbing expedition
- Goal for original data collection: Catalog climbing history in the region ([History of the Himalayan Database](https://www.himalayandatabase.com/history.html))

```{r message=FALSE}
library(tidyverse)
exped <- read_csv("data/mountaineering_expeditions.csv")
```

[^1]: Source: [TidyTuesday](https://github.com/rfordatascience/tidytuesday/blob/main/data/2025/2025-01-21/readme.md)


## Look at the variable names in the `exped` data frame

```{r output.lines=18}
names(exped)
```


## Look at data types and first few observations in the `exped` data frame

```{r output.lines=18}
glimpse(exped)
```


## How to use `dplyr` functions: example with `select`

We want to only include the `days_to_high_point` column (`days_to_high_point`= number of days between expedition start date and summit date):

::: {.columns}

::: {.column width = "50%" .fragment}
```{r}
exped # original exped data frame
```
:::

::: {.column width = "50%" .fragment}

```{r}
select(exped, days_to_high_point) # select only days_to_summit
```
:::
:::


## How to use `dplyr` functions: example with `select` {visibility="uncounted"}

::: {.columns}

::: {.column width = "50%"}
```{r eval=FALSE}
#| code-line-numbers: 1
select( 
  exped, 
  days_to_high_point
  )
```

:::

:::{.columnn width = "50%"}
- Start with the function (a verb): `select()`
:::
:::

## How to use `dplyr` functions: example with `select` {visibility="uncounted"}

::: {.columns}

::: {.column width = "50%"}
```{r eval=FALSE}
#| code-line-numbers: "2"
select( 
  exped, 
  days_to_high_point
  )
```

:::

:::{.columnn width = "50%"}
- Start with the function (a verb): `select()`
- First argument: name of the data object we're working with (`exped`)
:::
:::

## How to use `dplyr` functions: example with `select` {visibility="uncounted"}

::: {.columns}

::: {.column width = "50%"}
```{r eval=FALSE}
#| code-line-numbers: "3"
select( 
  exped, 
  days_to_high_point
  )
```

:::

:::{.columnn width = "50%"}
- Start with the function (a verb): `select()`
- First argument: name of the data object we're working with (`exped`)
- Second argument: variable we want to select, `days_to_high_point`
:::
:::

## How to use `dplyr` functions: example with `select` {visibility="uncounted"}

::: {.columns}

::: {.column width = "50%"}
```{r}
#| code-line-numbers: "3"
select( 
  exped, 
  days_to_high_point
  )
```

:::

:::{.columnn width = "50%"}
- Result: data frame with `r nrow(exped)` rows and 1 column
:::
:::

# `dplyr` functions always expect a data frame and always result in a data frame


## Select multiple columns

View only the `pkname` and `days_to_high_point` variables:

```{r}
select(exped, pkname, days_to_high_point)
```

# What if we wanted to select these columns, and *then* arrange the data in descending order of days to reach a high point?

# Use the pipe operator `|>` 


## What is a pipe?

In programming, a pipe is a technique for passing information from one process to another.

::: {.columns}
::: {.column width = "50%"}

- Start with the `exped` data frame and pass it to the `select()` function
- Select the variables `exped` and `days_to_high_point`
:::
::: {.column width = "50%"}
```{r}
#| code-line-numbers: "1,2"

exped |> 
  select(pkname, days_to_high_point) |> 
  arrange(desc(days_to_high_point))
```
:::
:::


## What is a pipe? {visibility="uncounted"}

In programming, a pipe is a technique for passing information from one process to another.

- You can think about the following sequence of actions - find keys, 
unlock car, start car, drive to work, park.
- You need the first action in order to complete the second action
- Expressed as a set of nested functions in R pseudocode this would look like:
<br>
```{r eval=FALSE}
park(drive(start_car(find("keys"))))
```

## How does a pipe work? {visibility="uncounted"}

Writing it out using pipes give it a more natural (and easier to read) 
structure:
<br>
```{r eval=FALSE}
find("keys") |> 
  start_car() |> 
  drive(to = "work") |> 
  park()
```

## How does a pipe work? {visibility="uncounted"}

Start with a data frame
```{r}
exped
```

## How does a pipe work? {visibility="uncounted"}

Pipe the data down to the next line. With `dplyr` functions, data is *always* the first argument. When we pipe, we are telling R to use the output of the previous line as the data argument. The data argument is now implicit. 
```{r}
exped |>                     
  select(pkname, days_to_high_point)
```

## How does a pipe work? {visibility="uncounted"}

Now, pipe the output of line 2 to line 3. The output of line 2 implicitly becomes the data argument for line 3. 
```{r}
exped |>                     
  select(pkname, days_to_high_point) |>           
  slice_head(n=5) 
```

## How does a pipe work? {visibility="uncounted"}

Pipe one more time from line 3 to line 4. The output of line 3 implicitly becomes the data argument for line 4. You can pipe as many more times as you want/need. 
```{r}
exped |>                     
  select(pkname, days_to_high_point) |>     
  arrange(days_to_high_point) |>
  slice_head(n=5)
```

## How does a pipe work? {visibility="uncounted"}

Pipes allow us to use a sequence of functions on a dataset without having to save the output as a new object at each step. The output is piped from one step to the next and implicitly used as the data argument.

![](img/pipes.png){fig-align="center" alt-text="cartoon of pipes in R"}

## A note on piping (dplyr) and layering (ggplot)

- `|>` is used in **dplyr** pipelines: *we pipe the output of the previous line of code as the first input of the next line of code*
 <br>
- `+` is used in **ggplot2** plots is used for "layering:" *we create the plot in layers, separated by `+`*

## piping vs. layering

<br>
Nope!
```{r error=TRUE}
exped +
  select(pkname, days_to_high_point)
```

<br>

Yep!
```{r eval=FALSE}
exped |>
  select(pkname, days_to_high_point)
```

::: {style="font-size: 75%;"}
# You might see `%>%`. This is also a pipe (from the `magrittr` package). R now has it's own build-in pipe operator `|>` so that's what most people use.
:::

# `dplyr` functions rundown

# `dplyr::select`

## `select` to exclude variables

```{r}
#| code-line-numbers: "2"

exped |>
  select(-o2used) 
```


## `select` a range of variables

```{r}
#| code-line-numbers: "2"

exped |>
  select(expid:pkname) 
```

## `select` variables with certain characteristics

```{r}
#| code-line-numbers: "2"

exped |>
  select(starts_with("pk")) 
```

## `select` variables with certain characteristics

```{r}
#| code-line-numbers: "2"

exped |>
  select(ends_with("id")) 
```

## Some select helpers

- `starts_with()`: Starts with a prefix
- `ends_with()`: Ends with a suffix
- `contains()`: Contains a literal string
- `num_range()`: Matches a numerical range like x01, x02, x03
- `one_of()`: Matches variable names in a character vector
- `everything()`: Matches all variables
- `last_col()`: Select last variable, possibly with an offset
- `matches()`: Matches a regular expression (a sequence of symbols/characters expressing a string/pattern to be searched for within text)

# `dplyr::arrange`

## `arrange` in ascending / descending order

::: {.columns}

::: {.column width = "50%" .fragment}
**Ascending**
```{r}
#| code-line-numbers: "3"

exped |>
  select(pkname, year, highpoint) |>
  arrange(year) 
```
:::

::: {.column width = "50%" .fragment}
**Descending**
```{r}
#| code-line-numbers: "3"

exped |>
  select(pkname, year, highpoint) |>
  arrange(desc(year))  
```
:::
:::

# `dplyr::slice`

## `slice` to select certain observations by row number

`slice` to select first five rows
```{r}
#| code-line-numbers: "2"

exped |>
  slice(1:5) 
```


# `dplyr::filter`

## `filter` to select a subset of rows

```{r}
#| code-line-numbers: "1,3"

# Expeditions on Lhotse
exped |>
  filter(pkname == "Lhotse")
```

## `filter` for many conditions at once

::: {.columns}
::: {.column width = "50%"}
```{r}
#| code-line-numbers: "2,3,4,5"

exped |>
  filter( 
    pkname == "Lhotse",     
    days_to_high_point >= 40    
    ) |> 
  select(year, season_factor, days_to_high_point)
```
:::

:::{.column width = "50%"}
::: {.incremental}
-  `==` and `>=` are two of many "logical operators" that we use to produce TRUE/FALSE results. 
- When used in conjunction with `filter`, only the TRUE results are retained in the resulting data frame 
- e.g., only results where `pkname` is equal to Lhotse and `days_to_high_point` is greater than or equal to 40 are retained.
:::
:::
:::

## Logical operators in R

::: {.columns}
::: {.column width = "50%"}
operator       |     definition                    
---------------|   ------------------------------
`<`            |     less than                     
`<=`           |	    less than or equal to        
`>`            |     greater than                 
`>=`           |	    greater than or equal to     
`==`           |	    exactly equal to             
`!=`           |	    not equal to                 
`x & y`        |     `x` AND `y`                                
:::
::: {.column}
operator     | definition
--------------|----------------
`x`&nbsp;&#124;&nbsp;`y`     | `x` OR `y`
`is.na(x)`    | test if `x` is `NA`
`!is.na(x)`   | test if `x` is not `NA`
`x %in% y`    | test if `x` is in `y`
`!(x %in% y)` | test if `x` is not in `y`
`!x`          | not `x`
:::
:::

## Try it: ae-04 1-4

- Before you try to push any changes, don't forget to use `gitcreds::gitcreds_set()` to set your PAT.
- Before pushing, make sure to *render, stage, commit* and then *push* to GitHub

# `dplyr::distinct` and `dplyr::count`

## `distinct` to filter for unique rows

Get unique values of the `pkname` variable and arrange in alphabetical order.
```{r}
#| code-line-numbers: "2,3"

exped |> 
  distinct(pkname) |> 
  arrange(pkname)
```

## `distinct` to filter for unique rows

Get unique combinations of the `pkname` and `season_factor` variables and arrange in alphabetical order by `pkname` first and `season_factor` second.
```{r}
#| code-line-numbers: "2,3"

exped |> 
  distinct(pkname, season_factor) |>
  arrange(pkname, season_factor)
```


## `count` to create frequency tables

::: {.columns}
:::{.column width = "50%" .fragment}
Alphabetical order by default
```{r}
#| code-line-numbers: "2"

exped |>
  count(pkname) 
```
:::
::: {.column width = "50%" .fragment}
Descending order by frequency
```{r}
#| code-line-numbers: "2"

exped |>
  count(pkname, sort = TRUE) 
```
:::
:::

## `count` for multiple variables

Get the number of observations for each unique combination of `pkname` and `season_factor`
```{r}
#| code-line-numbers: "2"

exped |>
  count(pkname, season_factor) 
```

# Try it: ae-04 5-6

# `dplyr::mutate`

## `mutate` to add a new variable

`mutate` creates a new column based on whatever arguments you provide, often using other existing colunns in the dataframe.

```{r}
#| code-line-numbers: "2,3,4"

exped |>
  mutate(weeks_to_high_point = days_to_high_point / 7) |> 
  select(expid, days_to_high_point, weeks_to_high_point) |>
  arrange(desc(weeks_to_high_point))
```

# `dplyr::summarise` and `dplyr::group_by`

## use `summarise` to calculate summary stats

Calculate mean `days_to_high_point` for all expeditions and assign the resulting output to a variable named `mean_days`.

```{r}
#| code-line-numbers: "2"

exped |>
  summarise(mean_days = mean(days_to_high_point)) 
```
::: {.incremental}
- `summarise()` changes the data frame entirely: it collapses rows down to a single 
summary statistic, and removes all columns that are not included in the calculation.
:::

## `group_by` for grouped summary calculations

Calculate mean average days to high point for all expeditions for each peak
```{r}
#| code-line-numbers: "2"

exped |>
  group_by(pkname) |> 
  summarise(mean_days = mean(days_to_high_point))
```

## Multiple summary statistics

`summarise` can be used for multiple summary statistics

```{r}
#| code-line-numbers: "2,3,4,5,6,7"

exped |>
  summarise(
    min_days = min(days_to_high_point),
    mean_days = mean(days_to_high_point),
    median_days = median(days_to_high_point),
    max_days = max(days_to_high_point)
    )
```

# Try it: ae-04 7-8
